python:

class Solution(object):
    def longestPalindrome(self, s):
        # l=0
        # start=0
        # for i in xrange(len(s)):
        #     if i-l>=1 and s[i-l-1:i+1]==s[i-l-1:i+1][::-1]:
        #         start=i-l-1
        #         l+=2
        #     elif s[i-l:i+1]==s[i-l:i+1][::-1]:
        #         start=i-l
        #         l+=1
        # return s[start:start+l]
        
        Manacher 算法
        
        tmp='#'+"#".join(s)+'#'
        size=len(tmp)
        r=[1]*size
        
        该位置字符对应的最大回文长度=r[i]-1
        axis=max_len=visited=pivot=0
        for i in range(size):
            if i<visited:
                r[i]=min(r[2*axis-i],visited-i)
            while i-r[i]>=0 and i+r[i]<size and tmp[i-r[i]]==tmp[i+r[i]]:
                r[i]+=1
            if r[i]+i-1>visited:
                visited,axis=r[i]+i-1,i
            if r[i]-1>max_len:
                max_len,pivot=r[i]-1,i
                
        max_r=(max_len)>>1
        if tmp[pivot]=='#':
            return s[(pivot>>1)-max_r:(pivot>>1)+max_r]
        return s[(pivot>>1)-max_r:(pivot>>1)+max_r+1]

java:

class Solution {
    public String longestPalindrome(String s) {
        StringBuilder tmp=new StringBuilder();
        int max_len=0,visited=0,axis=0,pivot=0;
        int size=(s.length()<<1)+1;
        
        for(int i=0;i<size;i++)
        {
            if((i&1)==0)
                tmp.append("#");
            else
                tmp.append(s.charAt(i>>1));
        }
        int[] r=new int[size];
        for(int i=0;i<size;i++)
        {
            if(i<visited)
                r[i]=r[2*axis-i]<visited-i?r[2*axis-i]:visited-i;
            else
                r[i]=1;
            while(i-r[i]>=0 && i+r[i]<size && tmp.charAt(i-r[i])==tmp.charAt(i+r[i]))
                r[i]++;
            if(i+r[i]-1>visited)
            {
                visited=i+r[i]-1;
                axis=i;
            }
            if(r[i]-1>max_len)
            {
                max_len=r[i]-1;
                pivot=i;
            }
        }
        int max_r=max_len>>1;
        if((pivot&1)==0)
            return s.substring((pivot>>1)-max_r,(pivot>>1)+max_r);
        return s.substring((pivot>>1)-max_r,(pivot>>1)+max_r+1);
    }
}
