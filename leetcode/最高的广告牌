你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。

你有一堆可以焊接在一起的钢筋 rods。举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。

返回广告牌的最大可能安装高度。如果没法安装广告牌，请返回 0。

 

示例 1：

输入：[1,2,3,6]
输出：6
解释：我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。
示例 2：

输入：[1,2,3,4,5,6]
输出：10
解释：我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。
示例 3：

输入：[1,2]
输出：0
解释：没法安装广告牌，所以返回 0。
 

提示：

0 <= rods.length <= 20
1 <= rods[i] <= 1000
钢筋的长度总和最多为 5000



思路：
将问题转化为求数组和为0时的组合
 
对任何一个数，可以用三种方式对待它，乘以1，-1或0，目标是求和为0时的最大正数和
 
例如，[1，2，3], 可以对1，2乘以1，3乘以-1，此时和为0， 最大正数和为1+2=3
用字典来存储每一步的结果，键和值分别是(k:v) 总和以及正数和，
初始化时dp={0:0},表示和为0时的最大长度为0
那么最后只需要求dp[0]的最大值
 
遍历所有钢筋：
对每根钢筋都有三种处理方式：加，减，丢 （对应乘以1，-1或0）
 
如：[1,2,3]
第一步: 用钢筋1，对初始的0，操作
如果加，那么总和是1，正数是1；如果减，总和是-1，正数0；如果丢，维持不变；更新dp={0:0, 1:1, -1:0}
第二步: 用钢筋2，对第一步中dp的键0，1，-1的基础上分别进行“加，减，丢 ”的操作
在0:0基础上，如果加，也就是变为2：2；如果减，变为 -2：0； 如果丢，变成0：0
类似的，在1：1基础上，加减丢变为3：3，-1：1，1：1
类似的，在-1：0基础上，加减丢变为1：2，-3：0，-1：0



class Solution {
    public int tallestBillboard(int[] rods) {
        HashMap<Integer,Integer> map=new HashMap<>(rods.length*rods.length);
        map.put(0,0);
        for(int x:rods){
            Map<Integer,Integer> m=(Map)map.clone();
            for(Map.Entry<Integer,Integer> e:m.entrySet()){
                int k=e.getKey();
                int v=e.getValue();
                int sum=map.getOrDefault(k+x,0);
                if(v+x>sum){
                    map.put(k+x,v+x);
                }
                sum=map.getOrDefault(k-x,0);
                if(v>sum){
                    map.put(k-x,v);
                }
            }
        }
        return map.get(0);
    }
}
