考虑下面的事件序列：
1.线程A发现变量没有被初始化, 然后它获取锁并开始变量的初始化。

2.由于某些编程语言的语义，编译器生成的代码允许在线程A执行完变量的初始化之前，更新变量并将其指向部分初始化的对象。

3.线程B发现共享变量已经被初始化，并返回变量。由于线程B确信变量已被初始化，它没有获取锁。
如果在A完成初始化之前共享变量对B可见（这是由于A没有完成初始化或者因为一些初始化的值还没有覆盖B使用的内存(缓存一致性)），程序很可能会崩溃。


这个问题其实说的是线程A正在执行instance = new Instance()的操作，而线程B开始执行if（instance==null）的判断，
当不存在volatile保证线程可见性以及保证构造函数在整个对象构造完成前执行完毕的时候，线程B可能会看到一个不完整的instance对象，
因为java的某些实现会在内存中开辟一片存储对象的区域后直接返回内存的引用，所以线程B判断不为null。从而得到不完整的对象。


jdk1.5之后，instance如果被声明成volatile的成员：

private static volatile Singleton instance = null; 

则可以解决此问题，因为volatile的变量，系统每次用到它时都是从内存中直接读取的
