1.单例模式

单例对象占用资源少，不需要延时加载：枚举式优于饿汉式
单例对象占用资源多，需要延时加载：静态内部类式优于懒汉式

--------------------------------------------------------

关于单例模式中双重检查锁存在的问题：

考虑下面的事件序列：
1.线程A发现变量没有被初始化, 然后它获取锁并开始变量的初始化。

2.由于某些编程语言的语义，编译器生成的代码允许在线程A执行完变量的初始化之前，更新变量并将其指向部分初始化的对象。

3.线程B发现共享变量已经被初始化，并返回变量。由于线程B确信变量已被初始化，它没有获取锁。
如果在A完成初始化之前共享变量对B可见（这是由于A没有完成初始化或者因为一些初始化的值还没有覆盖B使用的内存(缓存一致性)），程序很可能会崩溃。


这个问题其实说的是线程A正在执行instance = new Instance()的操作，而线程B开始执行if（instance==null）的判断，
当不存在volatile保证线程可见性以及保证构造函数在整个对象构造完成前执行完毕的时候，线程B可能会看到一个不完整的instance对象，
因为java的某些实现会在内存中开辟一片存储对象的区域后直接返回内存的引用，所以线程B判断不为null。从而得到不完整的对象。


jdk1.5之后，instance如果被声明成volatile的成员：

private static volatile Singleton instance = null; 

则可以解决此问题，因为volatile的变量，系统每次用到它时都是从内存中直接读取的

---------------------------------------------------------------------------

单例模式如何防止反射和反序列化的漏洞（枚举式没有此问题）：

//通过反射调用构造方法时，如果对象已存在，则抛出异常，防止二次创建对象
private SingletonDemo6(){ 
    if(instance!=null){
        throw new RuntimeException();
    }
}


//反序列化时，如果定义了readResolve()则直接返回此方法指定的对象。而不需要单独再创建新对象！
private Object readResolve() throws ObjectStreamException {
    return instance;
}

任何readObject方法，不管显示还是默认的，它会返回一个新建的实例，
这个新建实例不同于该类初始化时创建的实例，从而导致单例获取失败。
但序列化工具可以让开发人员通过readResolve来替换readObject中创建的实例，即使构造方法是私有的。
在反序列化时，新建对象上的readResolve方法会被调用，返回的对象将会取代readObject中新建的对象。

--------------------------------------------------------------------------------------
