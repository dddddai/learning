wait释放锁，sleep不释放锁

正确的方法是对在多线程间共享的那个Object来使用wait
notify()  唤醒在此对象监视器上等待的单个线程，仅通知一个线程，并且我们不知道哪个线程会收到通知
notifyAll()   唤醒在此对象监视器上等待的所有线程

希望上锁的对象就应该被synchronized，即那个在多个线程间被共享的对象。
在生产者消费者问题中，应该被synchronized的就是那个缓冲区队列。


1. 你可以使用wait和notify函数来实现线程间通信。你可以用它们来实现多线程（>3）之间的通信。

2. 永远在synchronized的函数或对象里使用wait、notify和notifyAll，不然Java虚拟机会生成 IllegalMonitorStateException。

3. 永远在while循环里而不是if语句下使用wait。这样，循环会在线程睡眠前后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知。
原因：当其他获取到该对象锁的线程释放锁时，wait的线程有可能被意外唤醒（就是重新获取锁），
但是此时该线程是不满足条件的，导致它破坏了被锁保护的约束关系，引起意外后果。
因此需要在被唤醒时再次检查wait的条件，需要两个if，while就是两个if的简化

4. 永远在多线程间共享的对象（在生产者消费者模型里即缓冲区队列）上使用wait。

5. 基于前文提及的理由，更倾向用 notifyAll()，而不是 notify()。


--------------------------------------------------------------------

当同步方法中发生异常时，自动释放锁，不会影响其他线程的执行

volatile只能保证可见性，不能保证原子性

--------------------------------------------------------------------

Unsafe是CAS的核心类，由于java方法无法直接访问底层系统，需要通过本地（native）方法来访问，
Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据，其内部方法可以像C的指针一样直接操作内存数据。

CAS并发原语体现在java语言中就是sun.misc.Unsafe类中的各个方法。
调用Unsafe类中的方法，JVM会帮我们实现CAS汇编指令
