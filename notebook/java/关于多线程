wait释放锁，sleep不释放锁

正确的方法是对在多线程间共享的那个Object来使用wait
notify()  唤醒在此对象监视器上等待的单个线程，仅通知一个线程，并且我们不知道哪个线程会收到通知
notifyAll()   唤醒在此对象监视器上等待的所有线程

希望上锁的对象就应该被synchronized，即那个在多个线程间被共享的对象。
在生产者消费者问题中，应该被synchronized的就是那个缓冲区队列。


1. 你可以使用wait和notify函数来实现线程间通信。你可以用它们来实现多线程（>3）之间的通信。

2. 永远在synchronized的函数或对象里使用wait、notify和notifyAll，不然Java虚拟机会生成 IllegalMonitorStateException。

3. 永远在while循环里而不是if语句下使用wait。这样，循环会在线程睡眠前后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知。
原因：当其他获取到该对象锁的线程释放锁时，wait的线程有可能被意外唤醒（就是重新获取锁），
但是此时该线程是不满足条件的，导致它破坏了被锁保护的约束关系，引起意外后果。
因此需要在被唤醒时再次检查wait的条件，需要两个if，while就是两个if的简化

4. 永远在多线程间共享的对象（在生产者消费者模型里即缓冲区队列）上使用wait。

5. 基于前文提及的理由，更倾向用 notifyAll()，而不是 notify()。
