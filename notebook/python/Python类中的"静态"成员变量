class task_queue:
    queue=[]
    
    def append(self,obj):
        self.queue.append(obj)
        
    def print_queue(self):
        print self.queue
        

if __name__=="__main__":
    a=task_queue()
    b=task_queue()
    c=task_queue()
    
    a.append('tc_1')
    
    a.print_queue()
    b.print_queue()
    c.print_queue()

我们期望在队列 a 中插入 tc_1，结果 b 和 c 也被同时操作了，这并不是我们所期望的

['tc_1']
['tc_1']
['tc_1']




Python 中并没有访问限定符 static，这种机制在 Python 中被称为 类的属性 和 对象的属性

第一段代码中的 queue 在类的声明中被初始化为空，这是 类的属性

a.append() 之后，queue 中添加了 'tc_1'，而 b 和 c 获取的 queue 依然是公共的 类的属性

如何让这个属性变为对象自己的呢？改动如下：

复制代码
class task_queue:
    
    def __init__(self):
        self.queue=[]
    
    def append(self,obj):
        self.queue.append(obj)
        
    def print_queue(self):
        print self.queue
复制代码
在构造对象实例时构造对象自己的属性 queue

['tc_1']
[]
[]


另一个例子

class a():  
    num = 0  

if __name__=="__main__":
    
    obj1 = a()  
    obj2 = a()   
    print obj1.num, obj2.num, a.num   
          
    obj1.num += 1  
    print obj1.num, obj2.num, a.num     
      
    a.num += 2  
    print obj1.num, obj2.num, a.num   

实例化 obj1 和 obj2 的时候，他们都没有对属性 num 进行操作，所以打印出来的都是类 a 的属性 num，也就是 0

后来 obj1 对自己的 num 进行 +1 之后，与类的属性脱离了关系，属性 num 就变成对象 obj1 自己的属性，
而 obj2 尝试打印属性 num 的时候还是从类的属性中去读取

第三段中，类的属性 +2 后，obj1.num 没有受到影响，而 obj2 尝试读取 num 属性时，依旧从类中去拿，所以它拿到的 num 是2


0 0 0
1 0 0
1 2 2


第一个例子，改变append方法

class task_queue:
    queue=[]
    
    def append(self,obj):
        self.queue=[obj]
        
    def print_queue(self):
        print self.queue
        


a=task_queue()
b=task_queue()
c=task_queue()
    
a.append('tc_1')
    
a.print_queue()
b.print_queue()
c.print_queue()


['tc_1']
[]
[]
