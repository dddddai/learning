题目描述
存在n+1个房间，每个房间依次为房间1 2 3...i，每个房间都存在一个传送门，i房间的传送门可以把人传送到房间pi(1<=pi<=i),
现在路人甲从房间1开始出发(当前房间1即第一次访问)，每次移动他有两种移动策略：
    A. 如果访问过当前房间 i 偶数次，那么下一次移动到房间i+1；
    B. 如果访问过当前房间 i 奇数次，那么移动到房间pi；
现在路人甲想知道移动到房间n+1一共需要多少次移动；

输入描述:
第一行包括一个数字n(30%数据1<=n<=100，100%数据 1<=n<=1000)，表示房间的数量，接下来一行存在n个数字 pi(1<=pi<=i), 
pi表示从房间i可以传送到房间pi。

输出描述:
输出一行数字，表示最终移动的次数，最终结果需要对1000000007 (10e9 + 7) 取模。

示例1

输入
2
1 2

输出
4

说明：
开始从房间1只访问一次所以只能跳到p1即房间1，之后采用策略A跳到房间2，房间2这时访问了一次因此采用策略B跳到房间2，
之后采用策略A跳到房间3，因此到达房间3需要 4 步操作。




记录第一次到达i为dp[i]，此时前面的所有门肯定是已经到达偶数次了
因为传送只会后退，前进的唯一方式是偶数次到达并+1，不能跳跃
所以到达i门前面所有门都走过并且经过偶数次
所以dp[i]=dp[i-1]+第二次到达i-1 + 1

第一次到达i-1门后再走一步会回到p[i-1]，此时p[i-1]门到达奇数次，其他所有门到达偶数次
这和第一次到达p[i-1]门的情况完全相同，所以从p[i-1]门回到i-1门，需要dp[i-1]-dp[p[i-1]]
所以dp[i] = dp[i-1] + dp[i-1] - dp[p[i-1]] + 1 + 1
dp[i] = 2 * dp[i-1] - dp[p[i-1]] + 2


import java.util.*;

public class Main{
    private static final int MOD=(int)1e9+7;
    
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        sc.nextLine();
        int[] arr=new int[n+1];
        int[] dp=new int[n+2];
        int result=0;
        for(int i=1;i<=n;++i){
            arr[i]=sc.nextInt();
        }
        sc.close();
        for(int i=2;i<=n+1;++i){
            dp[i]=((dp[i-1]<<1)-dp[arr[i-1]]+2)%MOD;
        }
        System.out.print(dp[n+1]<0 ? dp[n+1]+MOD:dp[n+1]);
    }
}
