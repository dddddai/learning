牛牛非常喜欢和朋友们一起玩。
牛牛有n个朋友当前在一根数轴上,每个朋友当前在整数x[i]坐标位置。
牛牛向他们发出一个移动的信号,每个朋友就向左或者向右移动s距离(每个朋友的选择是独立的,都可以选择向左或者向右)。
为了在一起玩耍方便,牛牛希望移动之后最左边的朋友和最右边的朋友距离最近,牛牛想知道最近距离为多少。

例如牛牛有三个朋友分别所在数轴坐标为-7, 4, 7, s = 5
那么第一个朋友-7向右移动s,变为-2
第二个朋友4向左移动s,变为-1
第三个朋友7向左移动s,变为2。
现在最左和最右的朋友距离是4,没有比这个更优的方案了。

输入描述:
输入包括两行,第一行两个正整数n和s(2 ≤ n ≤ 50, 0 ≤ s ≤ 10^8),表示朋友的个数和移动的距离。
第二行包括n个正整数x[i](-10^8 ≤ x[i] ≤ 10^8),表示初始时每个朋友所在的坐标位置。

输出描述:
输出一个正整数,表示移动之后最左边的朋友和最右边的朋友最小距离为多少。

示例1

输入
3 5
4 -7 7

输出
4



问题转换：如果先把所有点先向左移动s，所有点的可选操作就变成了原地不动或向右移动2s。
其中，向左移动s的步骤可省略，不影响结果。

解析思路：

先考虑最左边的点，如果向右移动2s后仍在最右点的左边，那么定左边界为移动后的位置，否则定左边界为最右点。(此左边界表示不可再右移的边界)
右边界为一个动态的值，初始为最右点。
再从左向右考虑点，如果向右移动2s后在右边界左边，直接跳过。（因为这个点不可能成为边界点）
直到某个点向右移动在右边界的右边，有两种选择。

保持不动，则得到一个距离，右边界到当前点，更新最短距离
右移2s，则更新右边界
之后的所有点都面临上面这两种情况，直到当前点位于了左边界右边。（因为左边界不可能在右移了，余下的点右移又会更新右边界，所有不用考虑了）



import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt(),s=sc.nextInt();
        sc.nextLine();
        int[] x=new int[n];
        for(int i=0;i<n;++i){
            x[i]=sc.nextInt();
        }
        sc.close();
        Arrays.sort(x);
        int dist=s<<1;
        int result=x[n-1]-x[0];
        int i=0;
        int left=Math.min(x[0]+dist,x[n-1]);
        int right=x[n-1];
        while(x[i]+dist<right){
            ++i;
        }
        while(i<n && x[i]<left){
            if(right-x[i]<result){
                result=right-x[i];
            }
            right=x[i++]+dist;
        }
        System.out.print(Math.min(result,right-left));
    }
}
